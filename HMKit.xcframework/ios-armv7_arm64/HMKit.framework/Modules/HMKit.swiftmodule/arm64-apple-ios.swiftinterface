// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.2 (swiftlang-1100.0.278 clang-1100.0.33.9)
// swift-module-flags: -target arm64-apple-ios10.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name HMKit
import CoreBluetooth
import CoreFoundation
import Foundation
import HMCryptoKit
import HMUtilities
import SafariServices
import Security
import Swift
import UIKit
import os
public class HMAccessCertificate : Swift.Codable {
  final public let bytes: [Swift.UInt8]
  final public let validity: HMKit.HMPeriod
  final public let version: HMKit.HMAccessCertificate.Version
  public var gainingPublicKey: [Swift.UInt8] {
    get
  }
  public var gainingSerial: [Swift.UInt8] {
    get
  }
  public var providingSerial: [Swift.UInt8] {
    get
  }
  public var permissions: [Swift.UInt8]? {
    get
  }
  public init?<C>(binary: C) where C : Swift.Collection, C.Element == Swift.UInt8
  convenience public init?(base64Encoded string: Swift.String)
  convenience public init?<C>(gainingSerial: C, gainingPublicKey: C, providingSerial: C, signature: C, validity: HMKit.HMPeriod, version: HMKit.HMAccessCertificate.Version, permissions: C? = nil) where C : Swift.Collection, C.Element == Swift.UInt8
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension HMAccessCertificate {
  public var isValidNow: Swift.Bool {
    get
  }
  public func isValid(on date: Foundation.Date) -> Swift.Bool
}
extension HMAccessCertificate : Swift.Equatable {
  public static func == (lhs: HMKit.HMAccessCertificate, rhs: HMKit.HMAccessCertificate) -> Swift.Bool
}
extension HMAccessCertificate : HMKit.HMSimilar {
  public static func ~= (lhs: HMKit.HMAccessCertificate, rhs: HMKit.HMAccessCertificate) -> Swift.Bool
}
extension HMAccessCertificate : HMKit.HMSigned {
}
public typealias HMAccessCertificateVersion = HMKit.HMAccessCertificate.Version
extension HMAccessCertificate {
  public enum Version {
    case basic
    case one(issuer: [Swift.UInt8])
    public var value: Swift.UInt8? {
      get
    }
  }
}
public class HMDeviceCertificate : Swift.Codable {
  final public let bytes: [Swift.UInt8]
  final public let version: HMKit.HMDeviceCertificate.Version
  public var appIdentifier: [Swift.UInt8] {
    get
  }
  public var issuer: [Swift.UInt8] {
    get
  }
  public var publicKey: [Swift.UInt8] {
    get
  }
  public var serial: [Swift.UInt8] {
    get
  }
  public init?<C>(binary: C) where C : Swift.Collection, C.Element == Swift.UInt8
  convenience public init?(base64Encoded string: Swift.String)
  convenience public init?<C>(appIdentifier: C, issuer: C, publicKey: C, serial: C, signature: C, version: HMKit.HMDeviceCertificate.Version) where C : Swift.Collection, C.Element == Swift.UInt8
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension HMDeviceCertificate : Swift.Equatable {
  public static func == (lhs: HMKit.HMDeviceCertificate, rhs: HMKit.HMDeviceCertificate) -> Swift.Bool
}
extension HMDeviceCertificate : HMKit.HMSigned {
}
public typealias HMDeviceCertificateVersion = HMKit.HMDeviceCertificate.Version
extension HMDeviceCertificate {
  public enum Version {
    case basic
    public var value: Swift.UInt8? {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public protocol HMBytesGettable {
  var bytes: [Swift.UInt8] { get }
}
public protocol HMSigned : HMKit.HMBytesGettable {
  var signature: [Swift.UInt8] { get }
  func isSignatureValid(forPublicKey publicKey: Security.SecKey) -> Swift.Bool
}
extension HMSigned {
  public var signature: [Swift.UInt8] {
    get
  }
  public func isSignatureValid(forPublicKey publicKey: Security.SecKey) -> Swift.Bool
}
public struct HMOAuthOptionalValues {
  public let state: Swift.String?
  public let validity: HMKit.HMPeriod?
  public init(state: Swift.String?, validity: HMKit.HMPeriod?)
}
public protocol HMSimilar {
  static func ~= (lhs: Self, rhs: Self) -> Swift.Bool
}
public struct HMOAuthSuccess {
  public let accessToken: Swift.String
  public let expiresIn: Foundation.TimeInterval
  public let refreshToken: Swift.String
  public let state: Swift.String?
}
public enum HMLocalDeviceState {
  case bluetoothUnavailable
  case idle
  case broadcasting
  public static func == (a: HMKit.HMLocalDeviceState, b: HMKit.HMLocalDeviceState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol HMValueGettable : Swift.Decodable, Swift.Encodable, Swift.Equatable {
  var value: Swift.UInt8? { get }
}
public struct HMTelematicsRequestError : Swift.Decodable, Swift.Error {
  public let detail: Swift.String?
  public let source: Swift.String?
  public let title: Swift.String
  public init(from decoder: Swift.Decoder) throws
}
public enum HMProtocolCommand : Swift.UInt8 {
  case getNonce
  case getDeviceCert
  case registerCert
  case getAccessCert
  case authenticate
  case secContainer
  case revoke
  case authenticateDone
  case error
  public typealias RawValue = Swift.UInt8
  public init?(rawValue: Swift.UInt8)
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol HMLinkDelegate {
  typealias Approve = () throws -> Swift.Void
  func link(_ link: HMKit.HMLink, authorisationRequestedBy serialNumber: [Swift.UInt8], approve: @escaping Self.Approve, timeout: Foundation.TimeInterval)
  func link(_ link: HMKit.HMLink, commandReceived bytes: [Swift.UInt8])
  func link(_ link: HMKit.HMLink, revokeCompleted bytes: [Swift.UInt8])
  func link(_ link: HMKit.HMLink, stateChanged newState: HMKit.HMLinkState, previousState: HMKit.HMLinkState)
  func link(_ link: HMKit.HMLink, receivedError error: HMKit.HMProtocolError)
}
public struct HMLocalDeviceConfiguration {
  public var broadcastingFilter: Foundation.Data? {
    get
    set
  }
  public var isAlivePingActive: Swift.Bool {
    get
    set
  }
  public var isBroadcastingFilterActive: Swift.Bool {
    get
  }
  public var isEncryptionEnabled: Swift.Bool
  public var overrideAdvertisementName: Swift.Bool
  public init<C>(broadcastingFilter: C? = nil, overrideAdvertisementName: Swift.Bool? = nil) where C : Swift.Collection, C.Element == Swift.UInt8
}
public typealias HMLinkCommandCompletionBlock = (Swift.Result<Swift.Void, HMKit.HMLinkError>) -> Swift.Void
public class HMLink {
  public var delegate: HMKit.HMLinkDelegate?
  public var certificate: HMKit.HMAccessCertificate? {
    get
    }
  public var state: HMKit.HMLinkState {
    get
    }
  @objc deinit
}
extension HMLink {
  public func disconnect()
  public func send<C>(command: C, completion: @escaping HMKit.HMLinkCommandCompletionBlock) throws where C : Swift.Collection, C.Element == Swift.UInt8
  public func sendRevoke() throws
}
extension HMLink : Swift.Equatable {
  public static func == (lhs: HMKit.HMLink, rhs: HMKit.HMLink) -> Swift.Bool
}
extension HMLink : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol HMLocalDeviceDelegate {
  func localDevice(stateChanged newState: HMKit.HMLocalDeviceState, oldState: HMKit.HMLocalDeviceState)
  func localDevice(didReceiveLink link: HMKit.HMLink)
  func localDevice(didLoseLink link: HMKit.HMLink)
}
public typealias HMBase64String = Swift.String
public class HMLocalDevice {
  public static let shared: HMKit.HMLocalDevice
  public var certificate: HMKit.HMDeviceCertificate? {
    get
    }
  public var configuration: HMKit.HMLocalDeviceConfiguration
  public var delegate: HMKit.HMLocalDeviceDelegate?
  public var loggingOptions: HMKit.HMLoggingOptions {
    get
    set
  }
  public var name: Swift.String {
    get
    }
  public var state: HMKit.HMLocalDeviceState {
    get
    }
  @objc deinit
}
extension HMLocalDevice {
  public var links: [HMKit.HMLink] {
    get
  }
  public var registeredCertificates: [HMKit.HMAccessCertificate] {
    get
  }
  public var serial: [Swift.UInt8]? {
    get
  }
  public var storedCertificates: [HMKit.HMAccessCertificate] {
    get
  }
  public func disconnect()
  public func initialise(certificate: HMKit.HMDeviceCertificate, devicePrivateKey: Security.SecKey, issuerPublicKey: Security.SecKey) throws
  public func initialise(deviceCertificate: HMKit.HMBase64String, devicePrivateKey: HMKit.HMBase64String, issuerPublicKey: HMKit.HMBase64String) throws
  public func isAuthorised<C>(toVehicle serial: C) throws -> Swift.Bool where C : Swift.Collection, C.Element == Swift.UInt8
  public func register(certificate: HMKit.HMAccessCertificate) throws
  public func resetStorage()
  @discardableResult
  public func revokeCertificate<C>(withSerial serial: C, type: HMKit.HMSerialType) -> HMKit.HMAccessCertificate? where C : Swift.Collection, C.Element == Swift.UInt8
  public func startBroadcasting(with configuration: HMKit.HMLocalDeviceConfiguration? = nil) throws
  public func stopBroadcasting()
  public func store(certificate: HMKit.HMAccessCertificate)
}
public typealias HMOAuthResult = Swift.Result<HMKit.HMOAuthSuccess, HMKit.HMOAuthFailure>
public class HMOAuth {
  public static let shared: HMKit.HMOAuth
  public var appID: Swift.String! {
    get
    }
  public var authURI: Swift.String! {
    get
    }
  public var clientID: Swift.String! {
    get
    }
  public var redirectScheme: Swift.String! {
    get
    }
  public var tokenURI: Swift.String! {
    get
    }
  public var state: Swift.String? {
    get
    }
  public var validity: HMKit.HMPeriod? {
    get
    }
  public var animate: Swift.Bool
  @discardableResult
  public func handleCallback(with url: Foundation.URL) -> Swift.Bool
  public func requestAccessToken(refreshToken: Swift.String, state: Swift.String?)
  public func launchAuthFlow(appID: Swift.String, authURI: Swift.String, clientID: Swift.String, redirectScheme: Swift.String, tokenURI: Swift.String, state: Swift.String? = nil, validity: HMKit.HMPeriod? = nil, for viewController: UIKit.UIViewController, handler: @escaping (HMKit.HMOAuthResult) -> Swift.Void)
  public func launchAuthFlow(requiredValues: HMKit.HMOAuthRequiredValues, optionalValues: HMKit.HMOAuthOptionalValues?, for viewController: UIKit.UIViewController, handler: @escaping (HMKit.HMOAuthResult) -> Swift.Void)
  @objc deinit
}
public struct HMOAuthFailure : Swift.Error {
  public enum Reason {
    case accessDenied
    case internalError
    case invalidURL
    case localDeviceUninitialised
    case missingToken
    public static func == (a: HMKit.HMOAuthFailure.Reason, b: HMKit.HMOAuthFailure.Reason) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let reason: HMKit.HMOAuthFailure.Reason
  public let state: Swift.String?
}
public enum HMLinkError : Swift.Error {
  case bluetoothOff
  case bluetoothUnauthorised
  case commandInProgress
  case commandTooBig
  case internalError
  case invalidSignature
  case storageFull
  case timeOut
  case notConnected
  case unauthorised
  case unsupported
  public static func == (a: HMKit.HMLinkError, b: HMKit.HMLinkError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum HMLinkState {
  case authenticated
  case connected
  case disconnected
  public static func == (a: HMKit.HMLinkState, b: HMKit.HMLinkState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum HMSerialType {
  case gaining
  case providing
  public static func == (a: HMKit.HMSerialType, b: HMKit.HMSerialType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum HMLocalDeviceError : Swift.Error {
  case alreadyConnected
  case bluetooth(HMKit.HMBluetoothError)
  case internalError
  case invalidInput
  case uninitialised
}
public struct HMOAuthRequiredValues {
  public let appID: Swift.String
  public let authURI: Swift.String
  public let clientID: Swift.String
  public let redirectScheme: Swift.String
  public let tokenURI: Swift.String
  public init(appID: Swift.String, authURI: Swift.String, clientID: Swift.String, redirectScheme: Swift.String, tokenURI: Swift.String)
}
public enum HMBluetoothError {
  case alreadyBroadcasting
  case poweredOff
  case unauthorised
  case unsupported
  public static func == (a: HMKit.HMBluetoothError, b: HMKit.HMBluetoothError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct HMLoggingOptions : Swift.OptionSet {
  public static var activeOptions: HMKit.HMLoggingOptions
  public let rawValue: Swift.UInt16
  public var useDeviceConsole: Swift.Bool
  public static let error: HMKit.HMLoggingOptions
  public static let general: HMKit.HMLoggingOptions
  public static let command: HMKit.HMLoggingOptions
  public static let bluetooth: HMKit.HMLoggingOptions
  public static let telematics: HMKit.HMLoggingOptions
  public static let encryption: HMKit.HMLoggingOptions
  public static let maidu: HMKit.HMLoggingOptions
  public static let urlRequests: HMKit.HMLoggingOptions
  public static let oauth: HMKit.HMLoggingOptions
  public init(rawValue: Swift.UInt16)
  public typealias Element = HMKit.HMLoggingOptions
  public typealias ArrayLiteralElement = HMKit.HMLoggingOptions
  public typealias RawValue = Swift.UInt16
}
public struct HMPeriod : Swift.Codable {
  public let start: Foundation.Date
  public let end: Foundation.Date
  public init(start: Foundation.Date, end: Foundation.Date)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension HMPeriod : Swift.Equatable {
  public static func == (lhs: HMKit.HMPeriod, rhs: HMKit.HMPeriod) -> Swift.Bool
}
extension HMPeriod {
  public func isValid(on date: Foundation.Date) -> Swift.Bool
}
public enum HMProtocolError : Swift.UInt8, Swift.Error {
  case internalError
  case commandEmpty
  case commandUnknown
  case invalidData
  case storageFull
  case invalidSignature
  case unauthorised
  case invalidHMAC
  case timeout
  case notAccepted
  public typealias RawValue = Swift.UInt8
  public init?(rawValue: Swift.UInt8)
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct HMTelematicsCommandError : Swift.Error, Swift.CustomStringConvertible {
  public enum Origin : Swift.UInt8 {
    case server
    case receiver
    case container
    public typealias RawValue = Swift.UInt8
    public init?(rawValue: Swift.UInt8)
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum Reason : Swift.UInt8 {
    case internalError
    case invalidData
    case invalidHMAC
    case timeout
    public typealias RawValue = Swift.UInt8
    public init?(rawValue: Swift.UInt8)
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public let origin: HMKit.HMTelematicsCommandError.Origin
  public let reason: HMKit.HMTelematicsCommandError.Reason
  public var description: Swift.String {
    get
  }
}
public typealias HMTelematicsResult<Success> = Swift.Result<Success, HMKit.HMTelematicsError>
public typealias HMTelematicsResultBlock<Success> = (HMKit.HMTelematicsResult<Success>) -> Swift.Void
public class HMTelematics {
  public static var loggingOptions: HMKit.HMLoggingOptions {
    get
    set
  }
  public static var urlBasePath: Swift.String
  public class func downloadAccessCertificate(accessToken: Swift.String, completionWithSerial completion: @escaping HMKit.HMTelematicsResultBlock<[Swift.UInt8]>) throws
  public class func isAuthorisedToVehicle<C>(serial: C) throws -> Swift.Bool where C : Swift.Collection, C.Element == Swift.UInt8
  public class func sendCommand<C>(_ command: C, serial: [Swift.UInt8], completionWithResponse completion: @escaping HMKit.HMTelematicsResultBlock<[Swift.UInt8]>) throws where C : Swift.Collection, C.Element == Swift.UInt8
  @objc deinit
}
public enum HMTelematicsError : Swift.Error {
  case localDeviceUninitialised
  case invalidData
  case misc(Swift.Error)
  case response(HMKit.HMTelematicsRequestError)
  case command(HMKit.HMTelematicsCommandError)
}
extension HMKit.HMAccessCertificate.Version : HMKit.HMValueGettable {}
extension HMKit.HMDeviceCertificate.Version : HMKit.HMValueGettable {}
extension HMKit.HMDeviceCertificate.Version : Swift.Hashable {}
extension HMKit.HMLocalDeviceState : Swift.Equatable {}
extension HMKit.HMLocalDeviceState : Swift.Hashable {}
extension HMKit.HMProtocolCommand : Swift.Equatable {}
extension HMKit.HMProtocolCommand : Swift.Hashable {}
extension HMKit.HMProtocolCommand : Swift.RawRepresentable {}
extension HMKit.HMOAuthFailure.Reason : Swift.Equatable {}
extension HMKit.HMOAuthFailure.Reason : Swift.Hashable {}
extension HMKit.HMLinkError : Swift.Equatable {}
extension HMKit.HMLinkError : Swift.Hashable {}
extension HMKit.HMLinkState : Swift.Hashable {}
extension HMKit.HMSerialType : Swift.Equatable {}
extension HMKit.HMSerialType : Swift.Hashable {}
extension HMKit.HMBluetoothError : Swift.Equatable {}
extension HMKit.HMBluetoothError : Swift.Hashable {}
extension HMKit.HMProtocolError : Swift.Equatable {}
extension HMKit.HMProtocolError : Swift.Hashable {}
extension HMKit.HMProtocolError : Swift.RawRepresentable {}
extension HMKit.HMTelematicsCommandError.Origin : Swift.Equatable {}
extension HMKit.HMTelematicsCommandError.Origin : Swift.Hashable {}
extension HMKit.HMTelematicsCommandError.Origin : Swift.RawRepresentable {}
extension HMKit.HMTelematicsCommandError.Reason : Swift.Equatable {}
extension HMKit.HMTelematicsCommandError.Reason : Swift.Hashable {}
extension HMKit.HMTelematicsCommandError.Reason : Swift.RawRepresentable {}
